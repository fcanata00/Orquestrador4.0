#!/usr/bin/env bash
# lib/common.sh
# Common utilities for ports manager: logging, config, locks, traps, spinner, helpers
# Generated by GPT-5 Thinking mini on user's request.
set -Eeuo pipefail
shopt -s inherit_errexit 2>/dev/null || true

# -----------------------------
# Defaults (can be overridden by conf file or env vars)
# -----------------------------
PORTS_CONF="${PORTS_CONF:-/etc/ports.conf}"
PORTS_LOGDIR="${PORTS_LOGDIR:-/var/log/ports-manager}"
PORTS_ERRLOGDIR="${PORTS_ERRLOGDIR:-$PORTS_LOGDIR/errors}"
PORTS_LOCKDIR="${PORTS_LOCKDIR:-/var/lock/ports}"
PORTS_CACHEDIR="${PORTS_CACHEDIR:-/var/cache/ports}"
PORTS_DEBUG="${PORTS_DEBUG:-0}"
PORTS_DRYRUN="${PORTS_DRYRUN:-0}"
PORTS_ASSUMEYES="${PORTS_ASSUMEYES:-0}"
PORTS_COLOR="${PORTS_COLOR:-auto}"      # auto|always|never
PORTS_LOCK_TIMEOUT="${PORTS_LOCK_TIMEOUT:-120}"  # seconds
PORTS_LOCK_RETRY="${PORTS_LOCK_RETRY:-3}"

# Internal state
ACTIVE_LOCKS=()
SCRIPT_PID=$$
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
START_TIME="$(date +%s)"
LOG_DATE="$(date +%F)"
# fallback dirs if can't create /var ones
FALLBACK_BASE="/tmp/ports-${UID:-0}"

# Ensure dirs exist (with fallback)
_safe_mkdir_internal() {
  local d="$1" || return 1
  if mkdir -p "$d" 2>/dev/null; then
    return 0
  fi
  return 1
}

_init_dirs() {
  if ! _safe_mkdir_internal "$PORTS_LOGDIR"; then
    PORTS_LOGDIR="$FALLBACK_BASE/logs"
    mkdir -p "$PORTS_LOGDIR"
    echo "WARN: cannot create /var logdir, using fallback $PORTS_LOGDIR" >&2
  fi
  PORTS_ERRLOGDIR="${PORTS_ERRLOGDIR:-$PORTS_LOGDIR/errors}"
  mkdir -p "$PORTS_ERRLOGDIR" 2>/dev/null || mkdir -p "$PORTS_ERRLOGDIR"
  if ! _safe_mkdir_internal "$PORTS_LOCKDIR"; then
    PORTS_LOCKDIR="$FALLBACK_BASE/locks"
    mkdir -p "$PORTS_LOCKDIR"
    echo "WARN: cannot create /var lockdir, using fallback $PORTS_LOCKDIR" >&2
  fi
  mkdir -p "$PORTS_CACHEDIR" 2>/dev/null || mkdir -p "$PORTS_CACHEDIR"
}

_init_dirs

LOG_FILE="$PORTS_LOGDIR/$LOG_DATE.log"
ERR_LOG_FILE="$PORTS_ERRLOGDIR/$LOG_DATE.err.log"

# -----------------------------
# Colors (smart detection)
# -----------------------------
_detect_color_support() {
  if [[ "$PORTS_COLOR" == "never" ]]; then
    return 1
  fi
  if [[ "$PORTS_COLOR" == "always" ]]; then
    return 0
  fi
  # auto
  if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && [[ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]]; then
    return 0
  fi
  return 1
}

if _detect_color_support; then
  COLOR_RESET="\033[0m"
  COLOR_RED="\033[31m"
  COLOR_YELLOW="\033[33m"
  COLOR_GREEN="\033[32m"
  COLOR_BLUE="\033[34m"
  COLOR_GRAY="\033[90m"
else
  COLOR_RESET=""
  COLOR_RED=""
  COLOR_YELLOW=""
  COLOR_GREEN=""
  COLOR_BLUE=""
  COLOR_GRAY=""
fi

# -----------------------------
# Timestamp helper
# -----------------------------
timestamp() {
  date "+%F %T"
}

# -----------------------------
# Logging (terminal + file). Logs to file are without color.
# -----------------------------
_log_write_file() {
  local level="$1"; shift
  local msg="$*"
  printf "[%s] %s %s\n" "$level" "$(timestamp)" "$msg" >>"$LOG_FILE"
}

_log_write_errfile() {
  local level="$1"; shift
  local msg="$*"
  printf "[%s] %s %s\n" "$level" "$(timestamp)" "$msg" >>"$ERR_LOG_FILE"
}

info() {
  local msg="$*"
  printf "%b\n" "${COLOR_BLUE}[INFO]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg"
  _log_write_file "INFO" "$msg"
}

warn() {
  local msg="$*"
  printf "%b\n" "${COLOR_YELLOW}[WARN]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg" >&2
  _log_write_file "WARN" "$msg"
  _log_write_errfile "WARN" "$msg"
}

error() {
  local msg="$*"
  printf "%b\n" "${COLOR_RED}[ERROR]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg" >&2
  _log_write_file "ERROR" "$msg"
  _log_write_errfile "ERROR" "$msg"
}

success() {
  local msg="$*"
  printf "%b\n" "${COLOR_GREEN}[ OK ]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg"
  _log_write_file "OK" "$msg"
}

debug() {
  if [[ "${PORTS_DEBUG:-0}" -ne 1 ]]; then
    return 0
  fi
  local msg="$*"
  printf "%b\n" "${COLOR_GRAY}[DEBUG]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg"
  _log_write_file "DEBUG" "$msg"
}

# die: cleanup and exit
die() {
  local code=1
  if [[ $# -ge 2 ]]; then
    code="$2"
    shift
  fi
  local msg="$*"
  printf "%b\n" "${COLOR_RED}[FATAL]$(COLOR_RESET) ${COLOR_GRAY}$(timestamp) →${COLOR_RESET} $msg" >&2
  _log_write_file "FATAL" "$msg"
  _log_write_errfile "FATAL" "$msg"
  cleanup_locks || true
  # flush logs
  sync || true
  exit "$code"
}

# -----------------------------
# Config loader
# -----------------------------
load_config() {
  local cfg="${1:-$PORTS_CONF}"
  if [[ -f "$cfg" ]]; then
    debug "Loading config from $cfg"
    while IFS= read -r line || [[ -n "$line" ]]; do
      # strip comments and whitespace
      line="${line%%#*}"
      line="$(echo -e "${line}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
      [[ -z "$line" ]] && continue
      if [[ "$line" == *=* ]]; then
        local key="${line%%=*}"
        local val="${line#*=}"
        key="$(echo "$key" | tr -d '[:space:]')"
        # export variable if not already set in env
        if [[ -z "${!key:-}" ]]; then
          export "$key"="$val"
          debug "Config: $key=$val"
        fi
      else
        warn "Ignoring invalid config line: $line"
      fi
    done <"$cfg"
  else
    debug "Config file $cfg not found; using defaults and environment variables"
  fi
  # ensure dirs reflect possible overrides
  _init_dirs
}

# -----------------------------
# Detect distro / host info
# -----------------------------
detect_distro() {
  local id="" ver="" name=""
  if [[ -f /etc/os-release ]]; then
    id="$(. /etc/os-release; echo "$ID" 2>/dev/null || echo "")"
    ver="$(. /etc/os-release; echo "$VERSION_ID" 2>/dev/null || echo "")"
    name="$(. /etc/os-release; echo "$PRETTY_NAME" 2>/dev/null || echo "")"
  fi
  HOST_DISTRO_ID="${id:-unknown}"
  HOST_DISTRO_VERSION="${ver:-unknown}"
  HOST_DISTRO_NAME="${name:-Unknown}"
  info "Detetado host: $HOST_DISTRO_NAME (ID=$HOST_DISTRO_ID, VERSION=$HOST_DISTRO_VERSION)"
}

host_info() {
  printf "Host distro: %s\n" "${HOST_DISTRO_NAME:-Unknown}"
  printf "Kernel: %s\n" "$(uname -r)"
  printf "Shell: %s\n" "${SHELL:-unknown}"
  printf "Arch: %s\n" "$(uname -m)"
}

# -----------------------------
# Require tools
# -----------------------------
require_tools() {
  local missing=()
  for t in "$@"; do
    if ! command -v "$t" >/dev/null 2>&1; then
      missing+=("$t")
    fi
  done
  if [[ ${#missing[@]} -ne 0 ]]; then
    error "Ferramentas faltando: ${missing[*]}; instale-as e tente novamente"
    return 2
  fi
  return 0
}

# -----------------------------
# Safe mkdir (with permissions)
# -----------------------------
safe_mkdir() {
  local d="$1"
  if [[ -z "$d" ]]; then return 1; fi
  if [[ -d "$d" ]]; then return 0; fi
  mkdir -p --mode=0700 "$d" 2>/dev/null || mkdir -p "$d" || die "Não foi possível criar diretório $d"
  return 0
}

# -----------------------------
# Dry-run helpers
# -----------------------------
is_dryrun() {
  [[ "${PORTS_DRYRUN:-0}" -eq 1 ]]
}

run_or_dry() {
  if is_dryrun; then
    info "[DRY-RUN] $*"
    return 0
  fi
  debug "run: $*"
  eval "$@"
}

# -----------------------------
# Running with spinner
# -----------------------------
# spinner state vars
_SPINNER_PID=0
_SPINNER_MSG=""
_SPINNER_ACTIVE=0

_spinner_frame() {
  local i="$1"
  local frames=( '⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏' )
  echo -n "${frames[i % ${#frames[@]}]}"
}

_run_spinner_loop() {
  local i=0
  while :; do
    if [[ "$_SPINNER_ACTIVE" -ne 1 ]]; then break; fi
    local frame
    frame="$(_spinner_frame "$i")"
    printf "\r%b %s %s" "${COLOR_BLUE}[${frame}]${COLOR_RESET}" "$_SPINNER_MSG" "$(timestamp)"
    sleep 0.12
    i=$(( (i + 1) % 100 ))
  done
  printf "\r"
}

run_with_spinner() {
  local label="$1"; shift
  if is_dryrun; then
    info "[DRY-RUN] $label: $*"
    return 0
  fi
  if ! [[ -t 1 ]]; then
    info "$label: (non-interactive) running..."
    "$@"
    return $?
  fi
  _SPINNER_MSG="$label"
  _SPINNER_ACTIVE=1
  _run_spinner_loop &
  _SPINNER_PID=$!
  # run command
  local exitcode=0
  if ! "$@"; then
    exitcode=$?
  fi
  _SPINNER_ACTIVE=0
  wait "$_SPINNER_PID" 2>/dev/null || true
  if [[ "$exitcode" -eq 0 ]]; then
    success "$label completed"
  else
    error "$label failed (exit $exitcode)"
  fi
  return "$exitcode"
}

# -----------------------------
# Safe command execution variants
# -----------------------------
silent_run() {
  # Run command quietly, return exit code
  if is_dryrun; then
    info "[DRY-RUN] silent: $*"
    return 0
  fi
  "$@" >/dev/null 2>&1 || return $?
}

try_run() {
  # Run command capturing stdout/stderr; do not die on failure
  local out
  if out="$("$@" 2>&1)"; then
    debug "try_run success: $*"
    printf "%s" "$out"
    return 0
  else
    local rc=$?
    warn "try_run failed (rc=$rc): $* -- output: $out"
    return "$rc"
  fi
}

# -----------------------------
# Log split output (stdout/stderr) into files while still printing to terminal
# Usage: log_split_output <log-prefix> -- command args...
# -----------------------------
log_split_output() {
  if [[ $# -lt 3 ]]; then
    die "log_split_output usage: log_split_output <prefix> -- command..."
  fi
  local prefix="$1"; shift
  if [[ "$1" != "--" ]]; then
    die "log_split_output: missing -- separator"
  fi
  shift
  local stdout_log="$PORTS_LOGDIR/${prefix}_stdout.log"
  local stderr_log="$PORTS_ERRLOGDIR/${prefix}_stderr.log"
  # Use process substitution to tee stdout and stderr
  if is_dryrun; then
    info "[DRY-RUN] ${prefix} ${*}"
    return 0
  fi
  # Run command in subshell to capture both
  (
    # redirect stdout to tee -> file and stdout
    "$@" 2> >(tee -a "$stderr_log" >&2) | tee -a "$stdout_log"
  )
  return $?
}

# -----------------------------
# Locking primitives
# -----------------------------
_lockfile_path() {
  local name="$1"
  printf "%s/%s.lock" "$PORTS_LOCKDIR" "$name"
}

# Acquire lock with retries, timeout and PID validation + atomic write
acquire_lock() {
  local name="$1"
  local retries="${PORTS_LOCK_RETRY:-3}"
  local timeout="${PORTS_LOCK_TIMEOUT:-120}"
  local attempt=1
  local lockfile="$(_lockfile_path "$name")"
  local tmpfile="${lockfile}.$$.tmp"

  safe_mkdir "$PORTS_LOCKDIR"

  while :; do
    if [[ ! -e "$lockfile" ]]; then
      # create tmp then rename atomically
      printf "PID=%d\nUSER=%s\nCMD=%s\nDATE=%s\n" "$$" "${USER:-$(id -un)}" "$0" "$(timestamp)" >"$tmpfile"
      if mv -f "$tmpfile" "$lockfile" 2>/dev/null; then
        info "Lock acquired: $name (pid $$)"
        ACTIVE_LOCKS+=("$name")
        return 0
      else
        warn "Failed to move tmp lock to $lockfile; retrying..."
        rm -f "$tmpfile" || true
      fi
    else
      # file exists: validate
      local p pid_cmd p_user p_date
      # shellcheck disable=SC2016
      pid_cmd="$(sed -n 's/^PID=//p; s/^CMD=//p; s/^USER=//p; s/^DATE=//p' "$lockfile" | sed -n '1p;2p;3p;4p' || true)"
      # better parse
      pid="$(grep -E '^PID=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
      p_user="$(grep -E '^USER=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
      p_cmd="$(grep -E '^CMD=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
      p_date="$(grep -E '^DATE=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
      if [[ -n "$pid" ]] && [[ -d "/proc/$pid" ]]; then
        # further validate by comparing command line if possible
        if [[ -r "/proc/$pid/cmdline" ]]; then
          local live_cmdline
          live_cmdline="$(tr '\0' ' ' < /proc/$pid/cmdline 2>/dev/null || true)"
          if [[ -n "$live_cmdline" ]] && [[ "$live_cmdline" == *"$p_cmd"* ]]; then
            warn "Lock $name held by active PID $pid (cmd: $live_cmdline). Waiting..."
            # wait with spinner up to timeout/retries
            local waited=0
            while [[ $waited -lt $timeout ]]; do
              sleep 1
              waited=$((waited + 1))
              if [[ ! -d "/proc/$pid" ]]; then
                break
              fi
            done
            if [[ -d "/proc/$pid" ]]; then
              error "Timeout waiting for lock $name (held by PID $pid)"
              return 2
            else
              warn "Process $pid exited; cleaning stale lock $name"
              rm -f "$lockfile" || true
              continue
            fi
          else
            warn "PID $pid exists but command mismatch; treating as stale lock and removing"
            rm -f "$lockfile" || true
            continue
          fi
        else
          # cannot read cmdline, fallback: wait then remove
          warn "Cannot read /proc/$pid/cmdline; assuming stale after timeout"
          sleep 1
          if [[ -d "/proc/$pid" ]]; then
            error "Lock seems held and cannot verify process; aborting"
            return 2
          else
            rm -f "$lockfile" || true
            continue
          fi
        fi
      else
        warn "Found stale/orphan lock for $name (pid=$pid, user=$p_user, cmd=$p_cmd, date=$p_date). Cleaning up."
        rm -f "$lockfile" || true
        continue
      fi
    fi
    attempt=$((attempt + 1))
    if [[ $attempt -gt $retries ]]; then
      error "Failed to acquire lock $name after $retries attempts"
      return 3
    fi
    sleep 1
  done
}

# release_lock: only if owned by current PID (or forced)
release_lock() {
  local name="$1"
  local force="${2:-0}"
  local lockfile="$(_lockfile_path "$name")"
  if [[ ! -e "$lockfile" ]]; then
    debug "release_lock: $name not present"
    return 0
  fi
  local pid_in_file
  pid_in_file="$(grep -E '^PID=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
  if [[ "$pid_in_file" == "$$" ]] || [[ "$force" == "1" ]]; then
    rm -f "$lockfile" || true
    info "Lock released: $name"
    # remove from ACTIVE_LOCKS
    local idx=0 new=()
    for l in "${ACTIVE_LOCKS[@]:-}"; do
      if [[ "$l" != "$name" ]]; then new+=("$l"); fi
      idx=$((idx+1))
    done
    ACTIVE_LOCKS=("${new[@]}")
    return 0
  else
    warn "Not releasing lock $name: owned by PID $pid_in_file (current $$). Use force=1 to override."
    return 2
  fi
}

check_lock() {
  local name="$1"
  local lockfile="$(_lockfile_path "$name")"
  if [[ ! -e "$lockfile" ]]; then
    return 1
  fi
  local pid_in_file
  pid_in_file="$(grep -E '^PID=' "$lockfile" 2>/dev/null | cut -d'=' -f2 || true)"
  if [[ -n "$pid_in_file" ]] && [[ -d "/proc/$pid_in_file" ]]; then
    return 0
  fi
  return 1
}

# cleanup all active locks (called on exit)
cleanup_locks() {
  debug "Running cleanup_locks (ACTIVE_LOCKS=${ACTIVE_LOCKS[*]:-})"
  for name in "${ACTIVE_LOCKS[@]:-}"; do
    release_lock "$name" || true
  done
}

# show all locks status (simple)
lock_status() {
  printf "%-30s %-8s %-20s %s\n" "NAME" "PID" "USER" "DATE"
  for f in "$PORTS_LOCKDIR"/*.lock; do
    [[ -e "$f" ]] || continue
    local n pid user date cmd
    n="$(basename "$f" .lock)"
    pid="$(grep -E '^PID=' "$f" 2>/dev/null | cut -d'=' -f2 || echo '-')"
    user="$(grep -E '^USER=' "$f" 2>/dev/null | cut -d'=' -f2 || echo '-')"
    date="$(grep -E '^DATE=' "$f" 2>/dev/null | cut -d'=' -f2 || echo '-')"
    printf "%-30s %-8s %-20s %s\n" "$n" "$pid" "$user" "$date"
  done
}

# -----------------------------
# Trap & error handling
# -----------------------------
trap_error() {
  local err=$?
  local line="${1:-UNKNOWN}"
  local func="${2:-UNKNOWN}"
  local file="${3:-UNKNOWN}"
  if [[ "$err" -eq 0 ]]; then return 0; fi
  local msg="Error (rc=$err) at ${file}:${line} in ${func}()"
  error "$msg"
  if [[ "${PORTS_DEBUG:-0}" -eq 1 ]]; then
    # print a lightweight stack trace
    local i=0
    error "Stack trace (most recent call first):"
    while caller $i; do
      i=$((i + 1))
    done
  fi
  cleanup_locks || true
  return "$err"
}

cleanup_on_exit() {
  local rc=$?
  if [[ "$rc" -eq 0 ]]; then
    debug "Exiting normally (rc=0)"
  else
    warn "Exiting with rc=$rc"
  fi
  # stop spinner if active
  _SPINNER_ACTIVE=0
  sleep 0.05
  cleanup_locks || true
  # optionally compress logs older than N days (not implemented here)
  return "$rc"
}

setup_traps() {
  # ERR trap: pass line/function/file via special vars
  trap 'trap_error $LINENO ${FUNCNAME[0]:-main} ${BASH_SOURCE[0]:-}' ERR
  trap 'cleanup_on_exit' EXIT
  trap 'echo; warn "Interrupted by user"; cleanup_on_exit; exit 130' INT TERM
}

# -----------------------------
# Confirmation prompt (respects assume-yes)
# -----------------------------
confirm() {
  local prompt="${1:-Are you sure?}"
  if [[ "${PORTS_ASSUMEYES:-0}" -eq 1 ]]; then
    debug "Assume-yes enabled; auto-confirming: $prompt"
    return 0
  fi
  if ! [[ -t 0 ]]; then
    warn "Non-interactive and no --assume-yes; refusing to confirm"
    return 1
  fi
  read -r -p "$prompt [y/N]: " ans
  case "$ans" in
    [Yy]|[Yy][Ee][Ss]) return 0 ;;
    *) return 1 ;;
  esac
}

# -----------------------------
# Utility: human readable size
# -----------------------------
human_size() {
  local bytes="${1:-0}"
  if [[ "$bytes" -lt 1024 ]]; then printf "%d B" "$bytes"; return; fi
  local kb=$((bytes/1024))
  if [[ "$kb" -lt 1024 ]]; then printf "%d KiB" "$kb"; return; fi
  local mb=$((kb/1024))
  if [[ "$mb" -lt 1024 ]]; then printf "%d MiB" "$mb"; return; fi
  local gb=$((mb/1024))
  printf "%d GiB" "$gb"
}

# -----------------------------
# Time diff helper
# -----------------------------
time_diff() {
  local start="$1" end="$2"
  local diff=$((end - start))
  printf '%02dh:%02dm:%02ds\n' $((diff/3600)) $(((diff%3600)/60)) $((diff%60))
}

# -----------------------------
# Simple argument parser for global flags (can be called by scripts)
# Usage: parse_global_flags "$@"
# Sets PORTS_DEBUG, PORTS_DRYRUN, PORTS_ASSUMEYES accordingly and removes flags from ARGV.
# -----------------------------
parse_global_flags() {
  local -a newargs=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --debug) PORTS_DEBUG=1; shift ;;
      --dry-run|-n) PORTS_DRYRUN=1; shift ;;
      --assume-yes|-y) PORTS_ASSUMEYES=1; shift ;;
      --no-color) PORTS_COLOR=never; shift ;;
      --color) PORTS_COLOR=always; shift ;;
      --) shift; while [[ $# -gt 0 ]]; do newargs+=("$1"); shift; done; break ;;
      -*)
        # unknown global option: keep for script-specific parsing
        newargs+=("$1"); shift ;;
      *)
        newargs+=("$1"); shift ;;
    esac
  done
  # re-export ARGV for caller
  ARGV=("${newargs[@]:-}")
}

# -----------------------------
# End of library
# -----------------------------
debug "lib/common.sh loaded (pid=$$, script=$SCRIPT_NAME)"
