#!/usr/bin/env bash
# lfsctl config module (production-ready)
# Path suggestion: /usr/libexec/lfsctl/config.sh
# Purpose: safe, idempotent configuration management for LFSCTL
# Features: safe parsing (no eval), backups, integrity checks (sha256),
#           repair, reload, JSON export, inotify watch, lock integration,
#           dry-run/strict/verbose modes, CLI.
set -euo pipefail

# -------------------- Defaults (override in /etc/lfsctl.conf) --------------------
: "${LFSCTL_CONFIG:=/etc/lfsctl.conf}"
: "${LFSCTL_META_DIR:=/var/lfsctl/meta}"
: "${LFSCTL_BACKUP_RETENTION:=5}"           # keep 5 backups by default
: "${LFSCTL_CONFIG_MODE:=0600}"
: "${LFSCTL_CONFIG_OWNER:=root}"
: "${LFSCTL_CONFIG_GROUP:=lfsbuild}"
: "${LFSCTL_TEMPLATE_PATH:=/usr/libexec/lfsctl/config.template}"

# Behavior flags (can be set externally)
DRY_RUN=${DRY_RUN:-0}
STRICT=${STRICT:-0}
VERBOSE=${VERBOSE:-0}

# Internal state
_CONFIG_LOADED=0
_CONFIG_MAP=()
_CONFIG_ORDER=()
_CONFIG_HASH=""
_CONFIG_LAST_BACKUP=""
mkdir -p "${LFSCTL_META_DIR}" 2>/dev/null || true

# Lightweight logger wrapper (uses logger.sh if available)
_log() {
  local lvl="$1"; shift || true
  if type -t log_info >/dev/null 2>&1; then
    case "$lvl" in
      info) log_info "$@" ;;
      warn) log_warn "$@" ;;
      error) log_error "$@" ;;
      debug) log_debug "$@" ;;
      *) log_info "$@" ;;
    esac
  else
    case "$lvl" in
      error) >&2 printf 'ERROR: %s\n' "$*" ;;
      warn) >&2 printf 'WARN: %s\n' "$*" ;;
      debug) [[ "$VERBOSE" -ne 0 ]] && printf 'DEBUG: %s\n' "$*" ;;
      *) printf '%s\n' "$*" ;;
    esac
  fi
}

# Acquire optional config lock using lock.sh if available
_config_lock_acquire() {
  if type -t lock_acquire >/dev/null 2>&1; then
    lock_acquire "config" --timeout 10 || { _log warn "Could not acquire config lock"; return 1; }
    return 0
  fi
  return 0
}
_config_lock_release() {
  if type -t lock_release >/dev/null 2>&1; then
    lock_release "config" || true
  fi
}

# safe read lines: KEY=VAL only, no eval; returns 0 if any var loaded
_config_safe_parse() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  local line key val
  _CONFIG_MAP=()
  _CONFIG_ORDER=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    # strip comments and trim
    line="${line%%#*}"
    line="${line%"${line##*[![:space:]]}"}"
    line="${line#"${line%%[![:space:]]*}"}"
    [[ -z "$line" ]] && continue
    if [[ "$line" =~ ^([A-Z_][A-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      val="${BASH_REMATCH[2]}"
      # remove surrounding quotes
      if [[ "$val" =~ ^\"(.*)\"$ ]]; then val="${BASH_REMATCH[1]}"; fi
      if [[ "$val" =~ ^\'(.*)\'$ ]]; then val="${BASH_REMATCH[1]}"; fi
      # reject suspicious values containing backticks or $(
      if [[ "$val" =~ [\`\$\(] ]]; then
        _log warn "Ignoring suspicious value for $key in $file"
        continue
      fi
      _CONFIG_MAP["$key"]="$val"
      _CONFIG_ORDER+=("$key")
    else
      _log debug "Skipping non-kv line in $file: $line"
    fi
  done <"$file"
  _CONFIG_LOADED=1
  return 0
}

# compute sha256 for file (uses sha256sum or shasum)
_config_sha256() {
  local file="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$file" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$file" | awk '{print $1}'
  else
    echo ""
  fi
}

# backup current config (rotating)
config_backup() {
  local file="${1:-$LFSCTL_CONFIG}"
  if [[ ! -f "$file" ]]; then
    _log warn "No config to backup at $file"
    return 1
  fi
  _config_lock_acquire || _log warn "Continuing without config lock"
  local ts backup
  ts=$(date +"%Y%m%d-%H%M%S")
  backup="${LFSCTL_META_DIR}/backups/config-${ts}.conf"
  mkdir -p "$(dirname "$backup")" 2>/dev/null || true
  if [[ "$DRY_RUN" -eq 1 ]]; then
    _log info "dry-run: would copy $file -> $backup"
    _config_lock_release
    return 0
  fi
  cp -a "$file" "$backup" || { _log error "Failed to backup config"; _config_lock_release; return 2; }
  chmod 0400 "$backup" 2>/dev/null || true
  _CONFIG_LAST_BACKUP="$backup"
  # rotate old backups
  (cd "${LFSCTL_META_DIR}/backups" 2>/dev/null || true; ls -1tr config-*.conf 2>/dev/null | head -n -${LFSCTL_BACKUP_RETENTION} | xargs -r -n1 rm -f) 2>/dev/null || true
  _log info "Config backed up to $backup"
  _config_lock_release
  return 0
}

# generate a default template if missing
config_template() {
  local out="${1:-$LFSCTL_CONFIG}"
  if [[ -f "$out" ]]; then
    _log warn "File exists: $out; will not overwrite unless --force used"
    return 1
  fi
  if [[ "$DRY_RUN" -eq 1 ]]; then
    _log info "dry-run: would create template at $out"
    return 0
  fi
  mkdir -p "$(dirname "$out")" 2>/dev/null || true
  cat >"$out" <<'EOF'
# lfsctl configuration file - autogenerated template
# Edit only variables with UPPERCASE names. No shell expansions are allowed.
LFSCTL_VERSION="1.0"
LFSCTL_ROOT="/mnt/lfs"
LFSCTL_BUILD_USER="lfsbuild"
LFSCTL_BUILD_GROUP="lfsbuild"
LFSCTL_CACHE_DIR="/var/cache/lfsctl"
LFSCTL_LOG_DIR="/var/lfsctl/logs"
LFSCTL_LOCK_DIR="/var/lock/lfsctl"
LFSCTL_META_DIR="/var/lfsctl/meta"
LFSCTL_PORTS_DIR="/usr/ports"
LFSCTL_REPO_URL=""
LFSCTL_CHROOT_ENABLED="true"
LFSCTL_FAKEROOT_ENABLED="true"
# min tools (space or comma separated): tool:version
LFSCTL_MIN_TOOLS="gcc:10.2 make:4.2.1 tar:1.30 git:2.25 zstd:1.4.5 sha256sum:0"
EOF
  chown "${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}" "$out" 2>/dev/null || true
  chmod "$LFSCTL_CONFIG_MODE" "$out" 2>/dev/null || true
  _log info "Template created at $out"
  return 0
}

# atomic write config (creates backup and sets perms)
_config_atomic_write() {
  local src="$1" dst="${2:-$LFSCTL_CONFIG}"
  _config_lock_acquire || _log warn "Continuing without config lock"
  if [[ "$DRY_RUN" -eq 1 ]]; then
    _log info "dry-run: would update $dst from $src"
    _config_lock_release
    return 0
  fi
  config_backup "$dst" || true
  local tmp
  tmp="$(mktemp "${dst}.tmp.XXXX")"
  cat "$src" >"$tmp" || { _log error "Failed to write tmp config"; rm -f "$tmp"; _config_lock_release; return 2; }
  chmod "$LFSCTL_CONFIG_MODE" "$tmp" 2>/dev/null || true
  chown "${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}" "$tmp" 2>/dev/null || true
  mv -f "$tmp" "$dst" || { _log error "Failed to move tmp to $dst"; rm -f "$tmp"; _config_lock_release; return 3; }
  sync || true
  _log info "Config updated at $dst"
  _config_lock_release
  return 0
}

# load config and export values to environment
config_load() {
  local file="${1:-$LFSCTL_CONFIG}"
  if [[ ! -f "$file" ]]; then
    _log warn "Config file $file not found; creating template"
    config_template "$file" || true
  fi
  if ! _config_safe_parse "$file"; then
    _log error "Failed to parse config $file"
    return 2
  fi
  # compute hash
  _CONFIG_HASH="$(_config_sha256 "$file")"
  # export variables prefixed LFSCTL_ only from parsed map
  for k in "${_CONFIG_ORDER[@]}"; do
    local v="${_CONFIG_MAP[$k]}"
    export "$k"="$v"
  done
  # write JSON snapshot
  config_export_json "$file" >/dev/null 2>&1 || true
  _log info "Config loaded from $file (hash=${_CONFIG_HASH})"
  return 0
}

# validate config values and types; returns 0 if ok, non-zero otherwise
config_validate() {
  local file="${1:-$LFSCTL_CONFIG}"
  local strict="${2:-$STRICT}"
  if [[ -f "$file" ]]; then
    _config_safe_parse "$file" || { _log error "Parse failed"; return 2; }
  else
    _log error "No config file to validate: $file"; return 1
  fi
  local errors=0 warnings=0
  # required vars and basic type checks
  local required=(LFSCTL_ROOT LFSCTL_BUILD_USER LFSCTL_BUILD_GROUP LFSCTL_CACHE_DIR LFSCTL_LOG_DIR LFSCTL_LOCK_DIR LFSCTL_META_DIR)
  for r in "${required[@]}"; do
    if [[ -z "${_CONFIG_MAP[$r]:-}" ]]; then
      _log error "Missing required config variable: $r"
      errors=$((errors+1))
    fi
  done
  # check directories are absolute paths
  for k in LFSCTL_ROOT LFSCTL_CACHE_DIR LFSCTL_LOG_DIR LFSCTL_LOCK_DIR LFSCTL_META_DIR LFSCTL_PORTS_DIR; do
    local val="${_CONFIG_MAP[$k]:-}"
    if [[ -n "$val" && "${val:0:1}" != "/" ]]; then
      _log warn "$k should be an absolute path; current='$val'"
      warnings=$((warnings+1))
      # attempt auto-repair: prepend / if simple
      if [[ "$strict" -eq 0 ]]; then
        _log info "Auto-repair: converting $k to absolute path (./ -> /)"
        _CONFIG_MAP[$k]="/${val#/}"
      fi
    fi
  done
  # check config file permissions
  if [[ -f "$file" ]]; then
    local mode owner group
    mode=$(stat -c %a "$file" 2>/dev/null || echo "")
    owner=$(stat -c %U "$file" 2>/dev/null || echo "")
    group=$(stat -c %G "$file" 2>/dev/null || echo "")
    if [[ -n "$mode" && "$mode" -ne "$((10#$LFSCTL_CONFIG_MODE))" ]]; then
      _log warn "Config file mode is $mode but expected $LFSCTL_CONFIG_MODE"
      if [[ "$strict" -eq 0 ]]; then
        _log info "Fixing permissions for $file"
        chmod "$LFSCTL_CONFIG_MODE" "$file" 2>/dev/null || _log warn "chmod failed"
      fi
    fi
    if [[ -n "$owner" && "$owner" != "$LFSCTL_CONFIG_OWNER" ]]; then
      _log warn "Config owner is $owner expected ${LFSCTL_CONFIG_OWNER}"
      if [[ "$strict" -eq 0 ]]; then
        chown "${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}" "$file" 2>/dev/null || _log warn "chown failed"
      fi
    fi
  fi
  # integrity check: optional CONFIG_HASH field vs computed hash
  local saved_hash="${_CONFIG_MAP[CONFIG_HASH]:-}"
  local computed="$(_config_sha256 "$file")"
  if [[ -n "$saved_hash" && -n "$computed" && "$saved_hash" != "$computed" ]]; then
    _log warn "Config hash mismatch: saved=$saved_hash computed=$computed"
    warnings=$((warnings+1))
    if [[ "$strict" -ne 0 ]]; then
      _log error "Strict mode: failing due to config hash mismatch"; errors=$((errors+1))
    fi
  fi
  # version sanity (if provided)
  if [[ -n "${_CONFIG_MAP[LFSCTL_VERSION]:-}" ]]; then
    _log debug "Config version: ${_CONFIG_MAP[LFSCTL_VERSION]}"
  fi
  if (( errors > 0 )); then
    _log error "Config validation failed with $errors errors and $warnings warnings"
    return 3
  fi
  _log info "Config validation passed (warnings=$warnings)"
  return 0
}

# attempt to repair config: fix perms, missing dirs, owner, and basic fixes
config_repair() {
  local file="${1:-$LFSCTL_CONFIG}"
  _config_safe_parse "$file" || _log warn "Parse failed; attempting to create template"
  # fix permissions and owner
  if [[ -f "$file" ]]; then
    if [[ "$DRY_RUN" -eq 1 ]]; then _log info "dry-run: would chmod/chown $file"; else
      chmod "$LFSCTL_CONFIG_MODE" "$file" 2>/dev/null || _log warn "chmod failed"
      chown "${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}" "$file" 2>/dev/null || _log warn "chown failed"
    fi
  else
    _log info "Config missing; creating template"
    config_template "$file" || { _log error "Failed to create template"; return 2; }
  fi
  # ensure directories exist and have safe perms from map
  for k in LFSCTL_ROOT LFSCTL_CACHE_DIR LFSCTL_LOG_DIR LFSCTL_LOCK_DIR LFSCTL_META_DIR LFSCTL_PORTS_DIR; do
    local path="${_CONFIG_MAP[$k]:-}"
    if [[ -n "$path" ]]; then
      if [[ "$DRY_RUN" -eq 1 ]]; then
        _log info "dry-run: would ensure dir $path exists and owned by ${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}"
      else
        mkdir -p "$path" 2>/dev/null || _log warn "mkdir failed for $path"
        chown "${LFSCTL_CONFIG_OWNER}:${LFSCTL_CONFIG_GROUP}" "$path" 2>/dev/null || true
        chmod 2770 "$path" 2>/dev/null || true
      fi
    fi
  done
  _log info "Config repair completed"
  return 0
}

# export config as JSON snapshot for tooling
config_export_json() {
  local file="${1:-$LFSCTL_CONFIG}" out="${2:-${LFSCTL_META_DIR}/config-snapshot-$(date +%s).json}"
  _config_safe_parse "$file" || return 1
  if command -v jq >/dev/null 2>&1; then
    # construct JSON via jq-safe method
    local tmp
    tmp="$(mktemp "${out}.tmp.XXXX")"
    printf '{\n' >"$tmp"
    local first=1
    for k in "${_CONFIG_ORDER[@]}"; do
      local v="${_CONFIG_MAP[$k]}"
      if [[ $first -eq 1 ]]; then first=0; else printf ',\n' >>"$tmp"; fi
      printf '  "%s": %s' "$k" "$(jq -Rn --arg v "$v" '$v')" >>"$tmp"
    done
    printf '\n}\n' >>"$tmp"
    mv -f "$tmp" "$out" 2>/dev/null || true
    _log info "Exported config JSON to $out"
    return 0
  else
    # fallback: simple JSON (unsafe chars not escaped perfectly)
    printf '{\n' >"$out"
    local first=1
    for k in "${_CONFIG_ORDER[@]}"; do
      local v="${_CONFIG_MAP[$k]}"
      if [[ $first -eq 1 ]]; then first=0; else printf ',\n' >>"$out"; fi
      printf '  "%s": "%s"' "$k" "${v//\"/\\\"}" >>"$out"
    done
    printf '\n}\n' >>"$out"
    _log info "Exported simple config JSON to $out (jq missing)"
    return 0
  fi
}

# show diff between last backup and current config
config_diff() {
  local file="${1:-$LFSCTL_CONFIG}"
  local last
  last="$(ls -1t "${LFSCTL_META_DIR}/backups/config-"*".conf" 2>/dev/null | head -n1 || true)"
  if [[ -z "$last" ]]; then _log warn "No backups to diff against"; return 1; fi
  if command -v diff >/dev/null 2>&1; then
    diff -u "$last" "$file" || true
  else
    _log warn "diff not available"
    return 2
  fi
  return 0
}

# reload config into current shell (safe)
config_reload() {
  local file="${1:-$LFSCTL_CONFIG}"
  config_load "$file" || { _log error "Reload failed"; return 1; }
  _log info "Config reloaded into environment"
  return 0
}

# watch config for changes (inotifywait required)
config_watch() {
  local file="${1:-$LFSCTL_CONFIG}"
  if ! command -v inotifywait >/dev/null 2>&1; then
    _log warn "inotifywait missing; cannot watch"
    return 1
  fi
  _log info "Watching $file for changes..."
  # loop until killed
  while inotifywait -e close_write,move,create,modify "$(dirname "$file")" >/dev/null 2>&1; do
    _log info "Change detected in $(dirname "$file"); reloading..."
    config_reload "$file" || _log warn "Reload after change failed"
  done
}

# repair + reload flow: atomic update from given new config file
config_apply_new() {
  local newfile="$1"
  if [[ ! -f "$newfile" ]]; then _log error "No such file: $newfile"; return 1; fi
  _config_atomic_write "$newfile" "$LFSCTL_CONFIG" || return 2
  config_reload "$LFSCTL_CONFIG" || return 3
  _log info "Applied new config from $newfile"
  return 0
}

# CLI dispatcher
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  cmd="${1:-help}"; shift || true
  case "$cmd" in
    init) config_template "${1:-$LFSCTL_CONFIG}" ;;
    load) config_load "${1:-$LFSCTL_CONFIG}" ;;
    validate) config_validate "${1:-$LFSCTL_CONFIG}" ;;
    repair) config_repair "${1:-$LFSCTL_CONFIG}" ;;
    backup) config_backup "${1:-$LFSCTL_CONFIG}" ;;
    diff) config_diff "${1:-$LFSCTL_CONFIG}" ;;
    reload) config_reload "${1:-$LFSCTL_CONFIG}" ;;
    export-json) config_export_json "${1:-$LFSCTL_CONFIG}" "${2:-}" ;;
    apply) config_apply_new "${1:-}" ;;
    watch) config_watch "${1:-$LFSCTL_CONFIG}" ;;
    help) printf 'Usage: %s {init|load|validate|repair|backup|diff|reload|export-json|apply|watch}\n' "$0"; exit 0 ;;
    *) printf 'Unknown command: %s\n' "$cmd"; exit 2 ;;
  esac
fi

# end of config.sh
